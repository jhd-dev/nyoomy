# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AddTagInput {
  color: CategoryColor
  description: String
  icon: CategoryIcon
  label: String!
  taggedItem: TaggableInput
}

input AddTodoInput {
  description: String
  doesRepeat: Boolean
  endDate: DateTime
  isArchived: Boolean
  largestStreak: Int
  repeatPattern: String
  startDate: DateTime
  streak: Int
  title: String
}

"""Info on the availability of a unique input (i.e. username)"""
type AvailabilityDto {
  alternatives: [String!]
  attemptedInput: String
  fieldName: String!
  isAvailable: Boolean!
  timeChecked: DateTime!
}

"""Colors a user may associate with a category/tag"""
enum CategoryColor {
  BLUE
  DEFAULT
  GREEN
  RED
  YELLOW
}

"""The icons available to accompany category/tag titles"""
enum CategoryIcon {
  GLOBE
  ROCKET
  STAR
  WATER
}

type Chat {
  createdAt: DateTime!
  id: ID!
  isArchived: Boolean!
  members: User!
}

input CreateFeedbackInput {
  details: String!

  """The maximum rating a user had the option to give, i.e. 5 stars"""
  maxRating: Int
  purpose: String!

  """
  The user's rating out of 10, e.g. 2.5 of 5 stars would yield a value of 5
  """
  rating: Int
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type EditFeedbackDto {
  success: Boolean!
}

input EditMessageInput {
  content: String!
  messageId: String!
}

type FieldError {
  field: String!
  message: String!
}

type Journal {
  dailyWordGoal: Int!
  id: ID!
  isArchived: Boolean!
  user: User!
}

type LoginResponse {
  error: String
  user: SafeUser
}

type Message {
  chat: Chat!
  content: String!
  edittedAt: DateTime!
  id: ID!
  sender: User!
  sentAt: DateTime!
}

type Mutation {
  addTodo(input: AddTodoInput!): TodoDto
  createTag(input: AddTagInput!): TagDto
  deleteMessage(messageId: ID!): Boolean
  deleteTag(id: ID!): Boolean!
  deleteTodo(id: ID!): Boolean!
  deleteUser: Boolean!
  deleteUserById(id: ID!): Boolean!
  editMessage(input: EditMessageInput!): Message
  login(input: UserLoginInput!): LoginResponse
  logout: Boolean!
  registerUser(input: RegisterUserInput!): RegistrationResponse!
  sendFeedback(input: CreateFeedbackInput!): EditFeedbackDto!
  sendMessageToChat(input: SendMessageToChatInput!): Message
  sendMessageToUser(input: SendMessageToUserInput!): Message
  updateSettings(input: UpdateUserSettingsInput!): UserSettingsDto
  updateTag(input: UpdateTagInput!): TagDto
  updateTodo(input: UpdateTodoInput!): TodoDto
  updateUserPassword(input: UpdatePasswordInput!): Boolean!
}

type Query {
  me: User
  myChats(excludeArchived: Boolean!): [Chat!]!
  mySettings: UserSettingsDto
  myTags: [TagDto!]!
  myTodo(id: ID!): TodoDto!
  myTodos(excludeArchived: Boolean): [TodoDto!]!
  randomAvailableUsername: String
  usernameAvailability(input: UsernameAvailabilityArgs!): AvailabilityDto!
}

"""User registration data"""
input RegisterUserInput {
  displayName: String!
  email: String!
  password: String!
  username: String!
}

type RegistrationResponse {
  errors: [FieldError!]
  user: SafeUser
}

"""User data excluding authentication-unsafe fields"""
type SafeUser {
  createdAt: DateTime!
  email: String!
  googleId: String!
  id: ID!
  isEmailVerified: Boolean!
  stars: Int!
  username: String!
}

input SendMessageToChatInput {
  chatId: String!
  content: String!
}

input SendMessageToUserInput {
  content: String!
  recipientId: String!
}

type TagDto {
  color: CategoryColor!
  description: String!
  icon: CategoryIcon
  id: ID!
  isArchived: Boolean!
  label: String!
}

input TaggableInput {
  id: ID!
}

"""The visual themes that can be used to style the app"""
enum ThemePreference {
  DARK
  DEVICE
  HIGH_CONTRAST
  LIGHT
  OLED
}

type TodoDto {
  description: String!
  doesRepeat: Boolean!
  endDate: DateTime
  id: ID!
  instances: [TodoInstance!]!
  isArchived: Boolean!
  largestStreak: Int!
  parent: TodoDto
  repeatPattern: String
  startDate: DateTime
  streak: Int!
  subtasks: [TodoDto!]!
  tags: [TagDto!]!
  title: String!
}

"""Particular instance of a potentially repeating todo."""
type TodoInstance {
  dueDate: DateTime
  id: ID!
  isCompleted: Boolean!
  offsetDueDate: DateTime
  todo: TodoDto!
}

input UpdatePasswordInput {
  newPassword: String!
  oldPassword: String!
  username: String!
}

input UpdateTagInput {
  applyTaggables: [TaggableInput!] = []
  color: CategoryColor
  description: String
  icon: CategoryIcon
  id: ID!
  isArchived: Boolean
  label: String
  removeTaggables: [TaggableInput!] = []
  taggables: [TaggableInput!]
}

input UpdateTodoInput {
  description: String
  doesRepeat: Boolean
  endDate: DateTime
  id: ID!
  isArchived: Boolean
  largestStreak: Int
  repeatPattern: String
  startDate: DateTime
  streak: Int
  tagUpdates: [UpdateTagInput!]
  title: String
}

input UpdateUserSettingsInput {
  audioEnabled: Boolean
  globalVolume: Int
  id: ID
  isPublic: Boolean
  language: String
  pin: String
  pinTimeout: Int
  themePreference: ThemePreference
}

"""Centralized user reference"""
type User {
  createdAt: DateTime!
  email: String!
  googleId: String!
  id: ID!
  isEmailVerified: Boolean!
  stars: Int!
  username: String!
}

input UserLoginInput {
  passwordInput: String!
  usernameOrEmail: String!
}

"""Users' settings and preferences"""
type UserSettingsDto {
  audioEnabled: Boolean!
  globalVolume: Int!
  id: ID!
  isPublic: Boolean!
  language: String!
  pin: String
  pinTimeout: Int
  themePreference: ThemePreference!
  user: SafeUser!
}

input UsernameAvailabilityArgs {
  recommendationsWanted: Int
  username: String
}
